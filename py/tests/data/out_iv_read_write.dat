#### TERMINATOR OP

## RET
            ; ret i32 0
            ; ret void
read:%62    ; ret double %62
read:%75    ; ret i32 %75
read:%47    ; ret i8 %47
read:%73    ; ret i64* %73
            ; ret { i32, i8 } { i32 4, i8 2 }
read:%26    ; ret %struct.node* %26
read:%42    ; ret i64 %42
read:%22    ; ret double %22

## BR
read:%18    ; br i1 %18, label %19, label %24
            ; br label %35
            ; br i1 true, label %12, label %76
            ; br label %7
read:%9     ; br i1 %9, label %10, label %57

## SWITCH
read:%8     ; switch i32 %8, label %61 [ i32 1, label %9 i32 2, label %25 i32 3, label %42 ]
read:%22    ; switch i32 %22, label %53 [ i32 1, label %23 i32 2, label %28 i32 3, label %33 i32 4, label %38 i32 5, label %43 i32 6, label %48 ]
read:%25    ; switch i64 %25, label %46 [ i64 1, label %26 i64 2, label %28 i64 3, label %30 i64 4, label %32 i64 5, label %34 i64 6, label %36 i64 7, label %38 i64 8, label %40 i64 9, label %42 i64 0, label %44 ]
            ; switch i32 0, label %dest [ ]

## INDIRECTBR (not found)
read:%Addr  ; indirectbr i8* %Addr, [ label %bb1, label %bb2, label %bb3 ] ; TODO Is this OK?

## INVOKE (not found)
# in the docs' examples seems that invoke is a valueInstruction
# but it is not looking in the grammar
#%retval = invoke i32 @Test(i32 15) to label %Continue unwind label %TestCleanup              ; i32:retval set
#%retval = invoke coldcc i32 %Testfnptr(i32 15) to label %Continue unwind label %TestCleanup              ; i32:retval set
    ; invoke i32 @Test(i32 15) to label %Continue unwind label %TestCleanup              ; i32:retval set
    ; invoke coldcc i32 %Testfnptr(i32 15) to label %Continue unwind label %TestCleanup              ; i32:retval set

## RESUME (not found)
read:%exn   ; resume { i8*, i32 } %exn ;; TODO Is this OK?

## CATCHSWITCH (not found)
# Same as 'invoke'.
#%cs1 = catchswitch within none [label %handler0, label %handler1] unwind to caller
#%cs2 = catchswitch within %parenthandler [label %handler0] unwind label %cleanup
    ; catchswitch within none [label %handler0, label %handler1] unwind to caller
    ; catchswitch within %parenthandler [label %handler0] unwind label %cleanup

## CATCHRETURN (not found)
read:%catch     ; catchret from %catch to label %continue

## CLEANUPRET (not found)
read:%cleanup   ; cleanupret from %cleanup unwind to caller
read:%cleanup   ; cleanupret from %cleanup unwind label %continue

## UNREACHABLE
; unreachable

#### BINARY OP

## ADD
read:%20 read:%21 write:%22     ; %22 = add nsw i32 %20, %21
read:%16 write:%17              ; %17 = add nsw i32 %16, 1
read:%29 write:%30              ; %30 = add nsw i32 %29, -1
read:%29 read:%33 write:%34     ; %34 = add i32 %29, %33
read:%42 write:%43              ; %43 = add i32 %42, 1
read:%13 write:%14              ; %14 = add nsw i64 %13, 1
read:%35 write:%36              ; %36 = add i8 %35, 1
read:%16 write:%17              ; %17 = add i64 %16, 1

## FADD
read:%13 write:%14          ; %14 = fadd double %13, 2.731500e+02
read:%18 read:%16 write:%19 ; %19 = fadd double %18, %16
read:%6 write:%7            ; %7 = fadd double %6, 2.731500e+02
read:%14 read:%15 write:%16 ; %16 = fadd float %14, %15
read:%15 write:%16          ; %16 = fadd float 1.000000e+00, %15

## SUB
read:%3 write:%4                ; %4 = sub nsw i32 %3, 1
read:%40 read:%44 write:%45     ; %45 = sub nsw i32 %40, %44
read:%52 read:%56 write:%57     ; %57 = sub nsw i32 %52, %56
read:%12 write:%13              ; %13 = sub i32 %12, 1
read:%11 read:%12 write:%13     ; %13 = sub nsw i64 %11, %12
read:%17 read:%18 write:%19     ; %19 = sub nsw i64 %17, %18
read:%25 write:%26              ; %26 = sub nsw i64 %25, 1
read:%16 write:%17              ; %17 = sub nsw i64 %16, 1

## FSUB
write:%30 read:%29          ; %30 = fsub double %29, 2.731500e+02
write:%36 read:%35          ; %36 = fsub double %35, 2.731500e+02
write:%31 read:%29 read:%30  ; %31 = fsub float %29, %30
write:%6 read:%5            ; %6 = fsub float %5, 3.200000e+01
write:%12 read:%9 read:%11  ; %12 = fsub float %9, %11

## MUL
write:%27 read:%25 read:%26 ; %27 = mul nsw i32 %25, %26
write:%30 read:%28 read:%29 ; %30 = mul nsw i32 %28, %29
write:%14 read:%13          ; %14 = mul i32 3, %13
write:%29 read:%28          ; %29 = mul i32 2, %28
write:%33 read:%32 read:%31 ; %33 = mul i32 %31, %32
write:%15 read:%14          ; %15 = mul i64 %14, 8
write:%19 read:%18          ; %19 = mul i64 %18, 8
write:%14 read:%13          ; %14 = mul nsw i32 %13, 2
write:%30 read:%26 read:%29 ; %30 = mul nsw i64 %26, %29
write:%38 read:%34 read:%37 ; %38 = mul nsw i64 %34, %37

## FMUL
write:%20 read:%19          ; %20 = fmul double %19, 9.000000e+00
write:%37 read:%36          ; %37 = fmul double %36, 9.000000e+00
write:%9 read:%8            ; %9 = fmul double 3.140000e+00, %8
write:%12 read:%9 read:%11  ; %12 = fmul double %9, %11
write:%16 read:%15          ; %16 = fmul double 6.280000e+00, %15
write:%10 read:%7 read:%9   ; %10 = fmul double %7, %9
write:%46 read:%44 read:%45 ; %46 = fmul float %44, %45
write:%15 read:%14          ; %15 = fmul double 0x3FB3333333333333, %14
write:%7 read:%6           ; %7 = fmul float %6, 5.000000e+00
write:%17 read:%13 read:%16 ; %17 = fmul float %13, %16
write:%21 read:%13 read:%20 ; %21 = fmul double %13, %20
write:%15 read:%14          ; %15 = fmul float %14, 1.200000e+01
write:%26 read:%25          ; %26 = fmul float %25, 1.000000e+02

## UDIV
write:%19 read:%18  ; %19 = udiv i32 %18, 10

## SDIV
write:%15 read:%14          ; %15 = sdiv i32 %14, 10
write:%18 read:%17          ; %18 = sdiv i32 %17, 2
write:%24 read:%23          ; %24 = sdiv i64 %23, 10
write:%18 read:%17          ; %18 = sdiv i64 %17, 2
write:%23 read:%21 read:%22 ; %23 = sdiv i64 %21, %22
write:%46 read:%44 read:%45 ; %46 = sdiv i64 %44, %45

## FDIV
write:%21 read:%20          ; %21 = fdiv double %20, 5.000000e+00
write:%38 read:%37          ; %38 = fdiv double %37, 5.000000e+00
write:%23 read:%21 read:%22 ; %23 = fdiv float %21, %22
write:%66 read:%64 read:%65 ; %66 = fdiv float %64, %65
write:%8 read:%7            ; %8 = fdiv float %7, 9.000000e+00
write:%15 read:%14          ; %15 = fdiv float %14, 1.000000e+02
write:%34 read:%26 read:%33 ; %34 = fdiv double %26, %33
write:%18 read:%16 read:%17 ; %18 = fdiv double %16, %17

## UREM
write:%23 read:%22          ; %23 = urem i32 %22, 3
write:%14 read:%13          ; %14 = urem i32 %13, 10
write:%21 read:%20          ; %21 = urem i64 %20, 12
write:%18 read:%14 read:%17 ; %18 = urem i32 %14, %17

## SREM
write:%25 read:%24          ; %25 = srem i32 %24, 10
write:%30 read:%28 read:%29 ; %30 = srem i32 %28, %29
write:%11 read:%10          ; %11 = srem i64 %10, 10
write:%38 read:%36 read:%37 ; %38 = srem i32 %36, %37
write:%49 read:%47 read:%48 ; %49 = srem i64 %47, %48
write:%26 read:%24 read:%25 ; %26 = srem i64 %24, %25
write:%6 read:%5            ; %6 = srem i32 %5, 2
write:%25 read:%24          ; %25 = srem i64 %24, 1000000007

## FREM (not found)
write:%X read:%var  ; %X = frem float 4.0, %var

#### BITWISE BINARY OP

## SHL
write:%7 read:%5 read:%6    ; %7 = shl i32 %5, %6
write:%27 read:%26          ; %27 = shl i64 %26, 1
write:%result read:%var     ; %result = shl i32 4, %var   ; yields i32: 4 << %var
write:%result               ; %result = shl i32 4, 2      ; yields i32: 16
write:%result               ; %result = shl i32 1, 10     ; yields i32: 1024
write:%result               ; %result = shl i32 1, 32     ; undefined
write:%result               ; %result = shl <2 x i32> < i32 1, i32 1>, < i32 1, i32 2>   ; yields: result=<2 x i32> < i32 2, i32 4>

## LSHR (not found)
write:%result   ; %result = lshr i32 4, 1   ; yields i32:result = 2
write:%result   ; %result = lshr i32 4, 2   ; yields i32:result = 1
write:%result   ; %result = lshr i8  4, 3   ; yields i8:result = 0
write:%result   ; %result = lshr i8 -2, 1   ; yields i8:result = 0x7F
write:%result   ; %result = lshr i32 1, 32  ; undefined
write:%result   ; %result = lshr <2 x i32> < i32 -2, i32 4>, < i32 1, i32 2>   ; yields: result=<2 x i32> < i32 0x7FFFFFFF, i32 1>

## ASHR
write:%14 read:%12 read:%13 ; %14 = ashr i32 %12, %13
write:%25 read:%24          ; %25 = ashr i64 %24, 1
write:%result               ; %result = ashr i32 4, 1   ; yields i32:result = 2
write:%result               ; %result = ashr i32 4, 2   ; yields i32:result = 1
write:%result               ; %result = ashr i8  4, 3   ; yields i8:result = 0
write:%result               ; %result = ashr i8 -2, 1   ; yields i8:result = -1
write:%result               ; %result = ashr i32 1, 32  ; undefined
write:%result               ; %result = ashr <2 x i32> < i32 -2, i32 4>, < i32 1, i32 3>   ; yields: result=<2 x i32> < i32 -1, i32 0>

## AND
write:%7 read:%5 read:%6    ; %7 = and i32 %5, %6
write:%8 read:%7 read:%6    ; %8 = and i32 %7, %6
write:%16 read:%15          ; %16 = and i32 %15, 1

## OR (not found)
write:%result read:%var     ; %result = or i32 4, %var         ; yields i32:result = 4 | %var
write:%result               ; %result = or i32 15, 40          ; yields i32:result = 47
write:%result               ; %result = or i32 4, 8            ; yields i32:result = 12

## XOR
write:%5 read:%4 ; %5 = xor i32 %4, -1
write:%25 read:%18 read:%24 ; %25 = xor i32 %18, %24
write:%8 read:%6 read:%7 ; %8 = xor i32 %6, %7
write:%11 read:%9 read:%10 ; %11 = xor i32 %9, %10
write:%14 read:%12 read:%13 ; %14 = xor i32 %12, %13
write:%result read:%var ; %result = xor i32 4, %var         ; yields i32:result = 4 ^ %var
write:%result ; %result = xor i32 15, 40          ; yields i32:result = 39
write:%result ; %result = xor i32 4, 8            ; yields i32:result = 12
write:%result read:%V ; %result = xor i32 %V, -1          ; yields i32:result = ~%V

#### VECTOR OP

## EXTRACTELEMENT (not found)
write:%result read:%vec ; %result = extractelement <4 x i32> %vec, i32 0    ; yields i32

## INSERTELEMENT (not found)
write:%result read:%vec; %result = insertelement <4 x i32> %vec, i32 1, i32 0    ; yields <4 x i32>

## SHUFFLEVECTOR (not found)
write:%result read:%v1 read:%v2; %result = shufflevector <4 x i32> %v1, <4 x i32> %v2, <4 x i32> <i32 0, i32 4, i32 1, i32 5>  ; yields <4 x i32>
write:%result read:%v1 ; %result = shufflevector <4 x i32> %v1, <4 x i32> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>  ; yields <4 x i32> - Identity shuffle.
write:%result read:%v1 ; %result = shufflevector <8 x i32> %v1, <8 x i32> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>  ; yields <4 x i32>
write:%result read:%v1 read:%v2; %result = shufflevector <4 x i32> %v1, <4 x i32> %v2, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7 >  ; yields <8 x i32>

#### AGGREGATE OP

## EXTRACTVALUE (not found)
write:%result read:%agg; %result = extractvalue {i32, float} %agg, 0    ; yields i32

## INSERTVALUE (not found)
write:%agg1 ; %agg1 = insertvalue {i32, float} undef, i32 1, 0              ; yields {i32 1, float undef}
write:%agg2 read:%agg1 read:%val ; %agg2 = insertvalue {i32, float} %agg1, float %val, 1         ; yields {i32 1, float %val}
write:%agg3 read:%val ; %agg3 = insertvalue {i32, {float}} undef, float %val, 1, 0    ; yields {i32 undef, {float %val}}

#### MEMORY ACCESS AND ADDRESSING OP

## ALLOCA
write:%1 ; %1 = alloca i32, align 4
write:%4 ; %4 = alloca double, align 8
write:%6 ; %6 = alloca i32, align 4
write:%7 ; %7 = alloca double, align 8
write:%2 ; %2 = alloca float, align 4
write:%3 ; %3 = alloca float, align 4
write:%7 ; %7 = alloca %struct.rect, align 4
write:%8 ; %8 = alloca %struct.rect, align 4
write:%4 ; %4 = alloca i8, align 1
write:%7 ; %7 = alloca i8, align 1
write:%4 ; %4 = alloca i32*, align 8
write:%5 ; %5 = alloca i32*, align 8
write:%8 ; %8 = alloca [10 x i32], align 16
write:%2 ; %2 = alloca [6 x i32], align 16
write:%2 ; %2 = alloca double, align 8
write:%3 ; %3 = alloca double, align 8
write:%4 ; %4 = alloca float, align 4
write:%13 read:%11 ; %13 = alloca i32, i64 %11, align 16
write:%16 read:%15 ; %16 = alloca i32, i64 %15, align 16
write:%2 ; %2 = alloca [20 x i8], align 16
write:%6 ; %6 = alloca i8**, align 8
write:%7 ; %7 = alloca i8**, align 8
write:%5 ; %5 = alloca i8**, align 8
write:%2 ; %2 = alloca [100 x i8], align 16
write:%1 ; %1 = alloca [20 x [20 x i8]], align 16
write:%2 ; %2 = alloca %struct.lcg_rand*, align 8
write:%3 ; %3 = alloca %struct.node*, align 8
write:%6 ; %6 = alloca i32*, align 8
write:%3 ; %3 = alloca %struct.task, align 4
write:%4 ; %4 = alloca %struct.task*, align 8
write:%2 ; %2 = alloca %struct.task**, align 8

## LOAD
write:%16 read:%4 ; %16 = load i32, i32* %4, align 4
write:%8 read:%5 ; %8 = load i32, i32* %5, align 4
write:%10 read:%6 ; %10 = load i32, i32* %6, align 4
write:%13 read:%4 ; %13 = load double, double* %4, align 8
write:%24 read:%3 ; %24 = load double, double* %3, align 8
write:%7 read:%2 ; %7 = load float, float* %2, align 4
write:%10 read:%2 ; %10 = load float, float* %2, align 4
write:%3 read:@position ; %3 = load i32, i32* @position, align 4
write:%14 read:@n ; %14 = load i32, i32* @n, align 4
write:%8 read:%7 ; %8 = load i8, i8* %7, align 1
write:%16 read:%7 ; %16 = load i8, i8* %7, align 1
write:%21 read:%11 ; %21 = load float, float* %11, align 4
write:%22 read:%12 ; %22 = load float, float* %12, align 4
write:%20 read:%5 ; %20 = load i32*, i32** %5, align 8
write:%27 read:%7 ; %27 = load i32*, i32** %7, align 8
write:%15 read:%11 ; %15 = load i8*, i8** %11, align 8
write:%8 read:@stdin ; %8 = load %struct._IO_FILE*, %struct._IO_FILE** @stdin, align 8
write:%24 read:%2 ; %24 = load i64, i64* %2, align 8
write:%26 read:%2 ; %26 = load i64, i64* %2, align 8
write:%80 read:%5 ; %80 = load i8*, i8** %5, align 8
write:%58 read:%8 ; %58 = load i64*, i64** %8, align 8
write:%18 read:%7 ; %18 = load i8**, i8*** %7, align 8
write:%50 read:%5 ; %50 = load i16, i16* %5, align 2
write:%4 read:%2 ; %4 = load %struct.lcg_rand*, %struct.lcg_rand** %2, align 8
write:%1 read:@first ; %1 = load %struct.node*, %struct.node** @first, align 8
write:%24 read:@head ; %24 = load %struct.node*, %struct.node** @head, align 8
write:%27 read:%6 ; %27 = load [3 x i32]*, [3 x i32]** %6, align 8
write:%48 read:%6 ; %48 = load [3 x i32]*, [3 x i32]** %6, align 8
write:%12 read:@s ; %12 = load i32, i32* getelementptr inbounds (%struct.student, %struct.student* @s, i32 0, i32 1), align 4
write:%14 read:@s ; %14 = load float, float* getelementptr inbounds (%struct.student, %struct.student* @s, i32 0, i32 2), align 4

## STORE
write:%1 ; store i32 0, i32* %1, align 44
write:%4 read:%0 ; store double %0, double* %4, align 8
write:%1 ; store i32 0, i32* %1, align 4
write:%4 read:%17 ; store float %17, float* %4, align 4
write:@choice ; store i32 20, i32* @choice, align 4
write:%3 read:%0 ; store i8* %0, i8** %3, align 8
read:@r ; store i32 10, i32* getelementptr inbounds ([5 x %struct.rect], [5 x %struct.rect]* @r, i64 0, i64 0, i32 0), align 16 ; TODO: in this case, constExpr is a write?
read:@r ; store i32 2, i32* getelementptr inbounds ([5 x %struct.rect], [5 x %struct.rect]* @r, i64 0, i64 0, i32 1), align 4
write:%7 read:%2 ; store i8 %2, i8* %7, align 1
write:%12 read:%5 ; store i32* %5, i32** %12, align 8
write:%3 read:%7 ; store double %7, double* %3, align 8
write:%5 read:%25 ; store i64 %25, i64* %5, align 8
write:%3 ; store float 0.000000e+00, float* %3, align 4
write:%4 ; store float 0.000000e+00, float* %4, align 4
write:%5 read:%12; store i8* %12, i8** %5, align 8
write:%6 read:%1; store i8** %1, i8*** %6, align 8
write:%7 read:%2; store i8** %2, i8*** %7, align 8
write:%74 read:%72 ; store i16 %72, i16* %74, align 2
write:%79 read:%77 ; store i16 %77, i16* %79, align 2
write:%2 read:%0; store %struct.lcg_rand* %0, %struct.lcg_rand** %2, align 8
write:@tail read:%15 ; store %struct.node* %15, %struct.node** @tail, align 8
write:@printFibonacci.n3 read:%8 ; store i32 %8, i32* @printFibonacci.n3, align 4
write:%2 ; store %struct.Node* null, %struct.Node** %2, align 8
write:%6 read:%2; store %struct.task* %2, %struct.task** %6, align 8
write:%2 read:@.str ; store i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i32 0, i32 0), i8** %2, align 8
write:%6 read:%2 ; store [3 x i32]* %2, [3 x i32]** %6, align 8
write:%3 ; store double 1.000000e+00, double* %3, align 8

## FENCE (not found)

; fence acquire                                        ; yields void
; fence syncscope("singlethread") seq_cst              ; yields void
; fence syncscope("agent") seq_cst                     ; yields void

## CMPXCHG (not found)
# Same as 'invoke'.
#%val_success = cmpxchg i32* %ptr, i32 %cmp, i32 %squared acq_rel monotonic ; yields  { i32, i1 }
read:%ptr write:%ptr read:%cmp read:%squared    ; cmpxchg i32* %ptr, i32 %cmp, i32 %squared acq_rel monotonic ; yields  { i32, i1 }

## ATOMICRMW (not found)
#Same as 'invoke'.
#%old = atomicrmw add i32* %ptr, i32 1 acquire                        ; yields i32
read:%ptr write:%ptr ; atomicrmw add i32* %ptr, i32 1 acquire                        ; yields i32

## GETELEMENTPTR
write:%22 read:%21 read:@arr    ; %22 = getelementptr inbounds [100 x i32], [100 x i32]* @arr, i64 0, i64 %21
write:%9 read:%8 read:@arr      ; %9 = getelementptr inbounds i32, i32* getelementptr inbounds ([100 x i32], [100 x i32]* @arr, i32 0, i32 0), i64 %8
write:%14 read:%13 read:@r      ; %14 = getelementptr inbounds [5 x %struct.rect], [5 x %struct.rect]* @r, i64 0, i64 %13
write:%16 read:%1 read:%15      ; %16 = getelementptr inbounds [20 x [20 x i8]], [20 x [20 x i8]]* %1, i64 0, i64 %15
write:%17 read:%16              ; %17 = getelementptr inbounds [20 x i8], [20 x i8]* %16, i32 0, i32 0
write:%39 read:%1 read:%38      ; %39 = getelementptr inbounds [20 x [20 x i8]], [20 x [20 x i8]]* %1, i64 0, i64 %38
write:%14 read:%13 read:@fact   ; %14 = getelementptr inbounds [2000001 x i64], [2000001 x i64]* bitcast (<{ i64, [2000000 x i64] }>* @fact to [2000001 x i64]*), i64 0, i64 %13
write:%27 read:%9 read:%26      ; %27 = getelementptr inbounds i8, i8* %9, i64 %26
write:%14 read:%12 read:%13     ; %14 = getelementptr inbounds i32, i32* %12, i64 %13
write:%38 read:%3               ; %38 = getelementptr inbounds %struct.task, %struct.task* %3, i32 0, i32 0
write:%9 read:%6 read:%8        ; %9 = getelementptr inbounds %struct.task, %struct.task* %6, i64 %8
write:%10 read:%9               ; %10 = getelementptr inbounds %struct.task, %struct.task* %9, i64 0
write:%21 read:%2               ; %21 = getelementptr inbounds [50 x i32], [50 x i32]* %2, i32 0, i32 0
write:%32 read:%2 read:%31      ; %32 = getelementptr inbounds [50 x i32], [50 x i32]* %2, i64 0, i64 %31
write:%11 read:%10              ; %11 = getelementptr inbounds i8, i8* %10, i64 2
write:%25 read:%22 read:%24     ; %25 = getelementptr inbounds i32, i32* %22, i64 %24
write:%27 read:%6 read:%26      ; %27 = getelementptr inbounds [10 x [10 x i32]], [10 x [10 x i32]]* %6, i64 0, i64 %26
write:%4 read:%2                ; %4 = getelementptr inbounds [4 x [3 x i32]], [4 x [3 x i32]]* %2, i32 0, i32 0
write:%8 read:%5 read:%7        ; %8 = getelementptr inbounds i8, i8* %5, i64 %7
write:%5 read:%3                ; %5 = getelementptr inbounds [100 x i8], [100 x i8]* %3, i32 0, i32 0
write:%69 read:%6               ; %69 = getelementptr inbounds [10 x i8], [10 x i8]* %6, i32 0, i32 0
write:%aptr read:%saptr         ; %aptr = getelementptr {i32, [12 x i8]}, {i32, [12 x i8]}* %saptr, i64 0, i32 1 ; yields [12 x i8]*:aptr
write:%vptr read:%svptr         ; %vptr = getelementptr {i32, <2 x i8>}, {i32, <2 x i8>}* %svptr, i64 0, i32 1, i32 1 ; yields i8*:vptr
write:%eptr read:%aptr          ; %eptr = getelementptr [12 x i8], [12 x i8]* %aptr, i64 0, i32 1 ; yields i8*:eptr
write:%iptr read:@arr           ; %iptr = getelementptr [10 x i32], [10 x i32]* @arr, i16 0, i16 0 ; yields i32*:iptr

## CONVERSION OP
write:%2 read:%1    ; %2 = trunc i64 %1 to i32
write:%47 read:%46  ; %47 = trunc i32 %46 to i8
write:%30 read:%29  ; %30 = zext i1 %29 to i64
write:%18 read:%17  ; %18 = zext i32 %17 to i64
write:%19 read:%18  ; %19 = zext i16 %18 to i32
write:%108 read:%107    ; %108 = sext i32 %107 to i64
write:%11 read:%10  ; %11 = sext i8 %10 to i32
write:%6 read:%5    ; %6 = sext i8 %5 to i32
write:%13 read:%12  ; %13 = fptrunc double %12 to float
write:%17 read:%16  ; %17 = fptrunc double %16 to float
write:%X            ; %X = fptrunc double 16777217.0 to float    ; yields float:16777216.0
write:%8 read:%7    ; %8 = fpext float %7 to double
write:%11 read:%10  ; %11 = fpext float %10 to double
write:%X            ; %X = fpext float 3.125 to double         ; yields double:3.125000e+00
write:%Y read:%X    ; %Y = fpext double %X to fp128            ; yields fp128:0xL00000000000000004000900000000000
write:%5 read:%4    ; %5 = fptoui double %4 to i32
write:%X ; %X = fptoui double 123.0 to i32      ; yields i32:123
write:%Y ; %Y = fptoui float 1.0E+300 to i1     ; yields undefined:1
write:%Z ; %Z = fptoui float 1.04E+17 to i8     ; yields undefined:1
write:%31 read:%30  ; %31 = fptosi double %30 to i32
write:%8 read:%7    ; %8 = fptosi float %7 to i32
write:%X ; %X = fptosi double -123.0 to i32      ; yields i32:-123
write:%Y ; %Y = fptosi float 1.0E-247 to i1      ; yields undefined:1
write:%Z ; %Z = fptosi float 1.04E+17 to i8      ; yields undefined:1
write:%15 read:%14  ; %15 = uitofp i32 %14 to float
write:%X ; %X = uitofp i32 257 to float         ; yields float:257.0
write:%Y ; %Y = uitofp i8 -1 to double          ; yields double:255.0
write:%27 read:%26  ; %27 = sitofp i32 %26 to double
write:%20 read:%19  ; %20 = sitofp i32 %19 to float
write:%12 read:%11  ; %12 = sitofp i64 %11 to double
write:%X ; %X = sitofp i32 257 to float         ; yields float:257.0
write:%Y ; %Y = sitofp i8 -1 to double          ; yields double:-1.0
write:%X read:%P    ; %X = ptrtoint i32* %P to i8                         ; yields truncation on 32-bit architecture
write:%Y read:%P    ; %Y = ptrtoint i32* %P to i64                        ; yields zero extension on 32-bit architecture
write:%Z read:%P    ; %Z = ptrtoint <4 x i32*> %P to <4 x i64>; yields vector zero extension for a vector of addresses on 32-bit architecture
write:%X ; %X = inttoptr i32 255 to i32*          ; yields zero extension on 64-bit architecture
write:%Y ; %Y = inttoptr i32 255 to i32*          ; yields no-op on 32-bit architecture
write:%Z ; %Z = inttoptr i64 0 to i32*            ; yields truncation on 32-bit architecture
write:%Z read:%G    ; %Z = inttoptr <4 x i32> %G to <4 x i8*>; yields truncation of vector G to four pointers
write:%10 read:%9   ; %10 = bitcast i8* %9 to %struct.rect*
write:%11 read:%7   ; %11 = bitcast %struct.rect* %7 to i8*
write:%4 read:%2    ; %4 = bitcast [6 x i32]* %2 to i8*
write:%3 read:%2    ; %3 = bitcast [156 x i8]* %2 to i8*
write:%4 read:%2    ; %4 = bitcast i32* %2 to i8*
write:%7 read:%6    ; %7 = bitcast i8* %6 to i32*
write:%16 read:%15  ; %16 = bitcast i8* %15 to %struct.task*
write:%3 read:%2    ; %3 = bitcast [4 x [3 x i32]]* %2 to i8*
write:%X ; %X = bitcast i8 255 to i8              ; yields i8 :-1
# From docs. Not working.
#%Y = bitcast i32* %x to sint*          ; yields sint*:%x
#%Z = bitcast <2 x int> %V to i64;        ; yields i64: %V
write:%Z read:%V    ; %Z = bitcast <2 x i32*> %V to <2 x i64*> ; yields <2 x i64*>
write:%X read:%x    ; %X = addrspacecast i32* %x to i32 addrspace(1)*    ; yields i32 addrspace(1)*:%x
write:%Y read:%y    ; %Y = addrspacecast i32 addrspace(1)* %y to i64 addrspace(2)*    ; yields i64 addrspace(2)*:%y
write:%Z read:%z    ; %Z = addrspacecast <4 x i32*> %z to <4 x float addrspace(3)*>   ; yields <4 x float addrspace(3)*>:%z

#### OTHER OP

## ICMP
write:%12 read:%11      ; %12 = icmp ult i32 %11, 10
write:%12 read:%11 read:%10           ;%12 = icmp ult <4xi32> %11, %10 ; invented
write:%9 read:%7 read:%8    ; %9 = icmp sgt i64 %7, %8
write:%16 read:%15      ; %16 = icmp ne %struct.node* %15, null
write:%31 read:%27 read:%30 ; %31 = icmp sle i32 %27, %30
write:%11 read:%9 read:%10  ; %11 = icmp slt i32 %9, %10
write:%23 read:%22      ; %23 = icmp eq %struct.Node* %22, null
write:%8 read:%7        ; %8 = icmp ne %struct.Node* %7, null
write:%8 read:%7        ; %8 = icmp ne i32 %7, 0
write:%85 read:%80 read:%84     ; %85 = icmp sgt i32 %80, %84
write:%94 read:%92 read:%93     ; %94 = icmp slt i32 %92, %93
write:%101 read:%99 read:%10    ; %101 = icmp sge i32 %99, %10
write:%15 read:%13 read:%14     ; %15 = icmp sle i32 %13, %14
write:%46 read:%45      ; %46 = icmp eq i32 %45, 0
write:%71 read:%70      ; %71 = icmp eq i32 %70, 0
write:%result           ; %result = icmp eq i32 4, 5          ; yields: result=false
write:%result read:%X   ; %result = icmp ne float* %X, %X     ; yields: result=false
write:%result           ; %result = icmp ult i16  4, 5        ; yields: result=true
write:%result           ; %result = icmp sgt i16  4, 5        ; yields: result=false
write:%result           ; %result = icmp ule i16 -4, 5        ; yields: result=false
write:%result           ; %result = icmp sge i16  4, 5        ; yields: result=false

## FCMP
write:%60 read:%59 ; %60 = fcmp oeq float %59, 0.000000e+00
write:%29 read:%28 ; %29 = fcmp oge float %28, 1.000000e+05
write:%37 read:%36 ; %37 = fcmp olt float %36, 1.000000e+05
write:%42 read:%41 ; %42 = fcmp oge float %41, 5.000000e+04
write:%12 read:%11 ; %12 = fcmp ogt double %11, 0x3E7AD7F29ABCAF48
write:%12 read:%11 ; %12 = fcmp ogt double %11, 0x3E7AD7F29ABCAF48
write:%10 read:%8 read:%9  ; %10 = fcmp ogt float %8, %9
write:%result  ; %result = fcmp oeq float 4.0, 5.0    ; yields: result=false
write:%result  ; %result = fcmp one float 4.0, 5.0    ; yields: result=true
write:%result  ; %result = fcmp olt float 4.0, 5.0    ; yields: result=true
write:%result  ; %result = fcmp ueq double 1.0, 2.0   ; yields: result=false

## PHI
write:%45 read:%43          ; %45 = phi i1 [ false, %36 ], [ false, %32 ], [ false, %28 ], [ %43, %40 ]
write:%28 read:%26          ; %28 = phi i1 [ true, %19 ], [ %26, %23 ]
write:%16 read:%12 read:%14 ; %16 = phi i32 [ %12, %11 ], [ %14, %13 ]
write:%32 read:%20 read:%30 ; %32 = phi float [ %20, %19 ], [ %30, %29 ]

## SELECT
write:%31 read:%29  ; %31 = select i1 %29, i32 1, i32 0
write:%23 read:%21  ; %23 = select i1 %21, i32 0, i32 1
write:%X            ; %X = select i1 true, i8 17, i8 42          ; yields i8:17

## CALL
write:%25 read:%24  ; %25 = call double @convertTemp(double %24, i32 1, i32 1)
; call void @menu()
write:%1 ; %1 = call i32 @bubble_sort_algo()
; call void @exit(i32 1) #3
write:%12 ; %12 = call i32 @main()
; call void @linear_search()
read:%11 read:%12   ; call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %11, i8* align 4 %12, i64 8, i1 false)
read:@area_comp read:@r    ; call void @qsort(i8* bitcast ([5 x %struct.rect]* @r to i8*), i64 5, i64 8, i32 (i8*, i8*)* @area_comp)
write:%27 read:@lock    ; %27 = call i32 @pthread_mutex_unlock(%union.pthread_mutex_t* @lock) #4
write:%28               ; %28 = call i32 @sleep(i32 10)
write:%1                ; %1 = call i64 @time(i64* null) #4
read:%2                 ; call void @srand(i32 %2) #4
write:%19 read:%18  ; %19 = call i32 @getRandom(i32 0, i32 %18)
read:%54 read:%55 read:%56 read:%57     ; call void @secondLine(i32 %54, i32 %55, i32 %56, i8 signext %57)
write:%28 read:%11 read:@scanf_s read:@.str.9 ; TODO: is read:scanf correct? ; %28 = call i32 (i8*, i32*, ...) bitcast (i32 (...)* @scanf_s to i32 (i8*, i32*, ...)*)(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.9, i32 0, i32 0), i32* %11)
write:%20 read:%19  ; %20 = call noalias i8* @malloc(i64 %19) #3
write:%9 read:%8 read:@.str.1   ; %9 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.1, i32 0, i32 0), i32 %8)
write:%14           ; %14 = call i64 @time(i64* null) #3
read:%51 read:%52   ; call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %51, i8* align 4 %52, i64 8, i1 false)
read:%4             ; call void @spiral_matrix(i32 4, i32 3, [3 x i32]* %4)
write:%11 read:%10  ; %11 = call double @llvm.fabs.f64(double %10)
write:%3 read:%2 read:@.str   ; %3 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i32 0, i32 0), i32* %2)
write:%5 read:%4    ; %5 = call double @squareRoot(i32 %4)
write:%6 read:%5 read:@.str.1   ; %6 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.1, i32 0, i32 0), double %5)
write:%11 read:%10  ; %11 = call double @llvm.fabs.f64(double %10)
write:%3 read:%2 read:@.str   ; %3 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i32 0, i32 0), i32* %2)
write:%5 read:%4    ; %5 = call double @squareRoot(i32 %4)
write:%6 read:%5 read:@.str.1   ; %6 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i32 0, i32 0), i8* %5)
write:%9 read:%8    ; %9 = call i32 @stringLength(i8* %8)
write:%11 read:@s   ; %11 = call i32 @puts(i8* getelementptr inbounds (%struct.student, %struct.student* @s, i32 0, i32 0, i32 0))
write:%10 read:%9 read:@.str.1  ; %10 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i32 0, i32 0), i8* %9)
write:%34 read:%33  ; %34 = call double @sqrt(double %33) #5
write:%45 read:%44 read:@.str.5 ; %45 = call i32 @strcmp(i8* %44, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.5, i32 0, i32 0)) #4
write:%81 read:%80  ; %81 = call double @pow(double %80, double 2.000000e+00) #5
write:%10 read:@.str.3          ; %10 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0))
write:%retval read:%argc    ; %retval = call i32 @test(i32 %argc)
read:%msg   ; call i32 (i8*, ...)* @printf(i8* %msg, i32 12, i8 42)        ; yields i32
write:%X    ; %X = tail call i32 @foo()                                    ; yields i32
write:%Y    ; %Y = tail call fastcc i32 @foo()  ; yields i32
# From docs. Not working.
#call void %foo(i8 97 signext)
write:%r    ; %r = call %struct.A @foo()                        ; yields { i32, i8 }
write:%Z    ; %Z = call void @foo() noreturn                    ; indicates that %foo never returns normally
write:%ZZ   ; %ZZ = call zeroext i32 @bar()                     ; Return value is %zero extended

## VA_ARG (not found)
write:%tmp read:%ap2    ; %tmp = va_arg i8* %ap2, i32

## LANDINGPAD (not found)
write:%res read:@_ZTIi     ; %res = landingpad { i8*, i32 } catch i8** @_ZTIi ;; A landing pad which can catch an integer.
write:%res                  ; %res = landingpad { i8*, i32 } cleanup ;; A landing pad that is a cleanup.
# From docs. Not working.
#%res = landingpad { i8*, i32 } catch i8** @_ZTIi filter [1 x i8**] [@_ZTId] ;; A landing pad which can catch an integer and can only throw a double.
# Not working.
#%0 = landingpad { i8*, i32 } filter [0 x i8*] zeroinitializer

## CATCHPAD (not found)
write:%tok ; %tok = catchpad within %cs [i8** @_ZTIi]

## CLEANUPPAD (not found)
write:%tok ; %tok = cleanuppad within %cs []
