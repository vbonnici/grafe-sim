#### TERMINATOR OP

## RET
;                ;ret i32 0
;                ;ret void
;%62-ty:double   ;ret double %62
;%75-ty:i32      ;ret i32 %75
;%47-ty:i8       ;ret i8 %47
;%73-ty:i64*     ;ret i64* %73
;                ;ret { i32, i8 } { i32 4, i8 2 }
;%26-ty:%struct.node*   ;ret %struct.node* %26
;%42-ty:i64             ;ret i64 %42
;%22-ty:double          ;ret double %22

## BR
;br i1 %18, label %19, label %24
;br label %35
;br i1 true, label %12, label %76
;br label %7
;br i1 %9, label %10, label %57

## SWITCH
; %8:i32  ;switch i32 %8, label %61 [ i32 1, label %9 i32 2, label %25 i32 3, label %42 ]
; %22:i32 ;switch i32 %22, label %53 [ i32 1, label %23 i32 2, label %28 i32 3, label %33 i32 4, label %38 i32 5, label %43 i32 6, label %48 ]
; %25:i64 ;switch i64 %25, label %46 [ i64 1, label %26 i64 2, label %28 i64 3, label %30 i64 4, label %32 i64 5, label %34 i64 6, label %36 i64 7, label %38 i64 8, label %40 i64 9, label %42 i64 0, label %44 ]
;         ;switch i32 0, label %dest [ ]

## INDIRECTBR (not found)
; %Addr:i8*   ;indirectbr i8* %Addr, [ label %bb1, label %bb2, label %bb3 ]

## INVOKE (not found)
# in the docs' examples seems that invoke is a valueInstruction
# but it is not looking in the grammar
#%retval = invoke i32 @Test(i32 15) to label %Continue unwind label %TestCleanup              ; i32:retval set
#%retval = invoke coldcc i32 %Testfnptr(i32 15) to label %Continue unwind label %TestCleanup              ; i32:retval set
    ;invoke i32 @Test(i32 15) to label %Continue unwind label %TestCleanup              ; i32:retval set
    ;invoke coldcc i32 %Testfnptr(i32 15) to label %Continue unwind label %TestCleanup              ; i32:retval set

## RESUME (not found)
    ;resume { i8*, i32 } %exn

## CATCHSWITCH (not found)
# Same as 'invoke'.
#%cs1 = catchswitch within none [label %handler0, label %handler1] unwind to caller
#%cs2 = catchswitch within %parenthandler [label %handler0] unwind label %cleanup
;catchswitch within none [label %handler0, label %handler1] unwind to caller
;catchswitch within %parenthandler [label %handler0] unwind label %cleanup

## CATCHRETURN (not found)
;catchret from %catch to label %continue

## CLEANUPRET (not found)
;cleanupret from %cleanup unwind to caller
;cleanupret from %cleanup unwind label %continue

## UNREACHABLE
;unreachable

#### BINARY OP

## ADD
%22-ty:i32      ;%22 = add nsw i32 %20, %21
%17-ty:i32      ;%17 = add nsw i32 %16, 1
%30-ty:i32      ;%30 = add nsw i32 %29, -1
%34-ty:i32      ;%34 = add i32 %29, %33
%43-ty:i32      ;%43 = add i32 %42, 1
%14-ty:i64      ;%14 = add nsw i64 %13, 1
%36-ty:i8       ;%36 = add i8 %35, 1
%17-ty:i64      ;%17 = add i64 %16, 1

## FADD
%14-ty:double  ;%14 = fadd double %13, 2.731500e+02
%19-ty:double  ;%19 = fadd double %18, %16
%7-ty:double   ;%7 = fadd double %6, 2.731500e+02
%16-ty:float   ;%16 = fadd float %14, %15
%16-ty:float   ;%16 = fadd float 1.000000e+00, %15

## SUB
%4-ty:i32      ;%4 = sub nsw i32 %3, 1
%45-ty:i32     ;%45 = sub nsw i32 %40, %44
%57-ty:i32     ;%57 = sub nsw i32 %52, %56
%13-ty:i32     ;%13 = sub i32 %12, 1
%13-ty:i64     ;%13 = sub nsw i64 %11, %12
%19-ty:i64     ;%19 = sub nsw i64 %17, %18
%26-ty:i64     ;%26 = sub nsw i64 %25, 1
%17-ty:i64     ;%17 = sub nsw i64 %16, 1

## FSUB
%30-ty:double ;%30 = fsub double %29, 2.731500e+02
%36-ty:double ;%36 = fsub double %35, 2.731500e+02
%31-ty:float  ;%31 = fsub float %29, %30
%6-ty:float   ;%6 = fsub float %5, 3.200000e+01
%12-ty:float  ;%12 = fsub float %9, %11

## MUL
%27-ty:i32  ;%27 = mul nsw i32 %25, %26
%30-ty:i32  ;%30 = mul nsw i32 %28, %29
%14-ty:i32  ;%14 = mul i32 3, %13
%29-ty:i32  ;%29 = mul i32 2, %28
%33-ty:i32  ;%33 = mul i32 %31, %32
%15-ty:i64  ;%15 = mul i64 %14, 8
%19-ty:i64  ;%19 = mul i64 %18, 8
%14-ty:i32  ;%14 = mul nsw i32 %13, 2
%30-ty:i64  ;%30 = mul nsw i64 %26, %29
%38-ty:i64  ;%38 = mul nsw i64 %34, %37

## FMUL
%20-ty:double   ;%20 = fmul double %19, 9.000000e+00
%37-ty:double   ;%37 = fmul double %36, 9.000000e+00
%9-ty:double    ;%9 = fmul double 3.140000e+00, %8
%12-ty:double   ;%12 = fmul double %9, %11
%16-ty:double   ;%16 = fmul double 6.280000e+00, %15
%10-ty:double   ;%10 = fmul double %7, %9
%46-ty:float   ;%46 = fmul float %44, %45
%15-ty:double   ;%15 = fmul double 0x3FB3333333333333, %14
%7-ty:float    ;%7 = fmul float %6, 5.000000e+00
%17-ty:float   ;%17 = fmul float %13, %16
%21-ty:double   ;%21 = fmul double %13, %20
%15-ty:float   ;%15 = fmul float %14, 1.200000e+01
%26-ty:float   ;%26 = fmul float %25, 1.000000e+02

## UDIV
%19-ty:i32      ;%19 = udiv i32 %18, 10

## SDIV
%15-ty:i32  ;%15 = sdiv i32 %14, 10
%18-ty:i32  ;%18 = sdiv i32 %17, 2
%24-ty:i64  ;%24 = sdiv i64 %23, 10
%18-ty:i64  ;%18 = sdiv i64 %17, 2
%23-ty:i64  ;%23 = sdiv i64 %21, %22
%46-ty:i64  ;%46 = sdiv i64 %44, %45

## FDIV
%21-ty:double   ;%21 = fdiv double %20, 5.000000e+00
%38-ty:double   ;%38 = fdiv double %37, 5.000000e+00
%23-ty:float      ;%23 = fdiv float %21, %22
%66-ty:float      ;%66 = fdiv float %64, %65
%8-ty:float     ;%8 = fdiv float %7, 9.000000e+00
%15-ty:float      ;%15 = fdiv float %14, 1.000000e+02
%34-ty:double   ;%34 = fdiv double %26, %33
%18-ty:double   ;%18 = fdiv double %16, %17

## UREM
%23-ty:i32  ;%23 = urem i32 %22, 3
%14-ty:i32  ;%14 = urem i32 %13, 10
%21-ty:i64  ;%21 = urem i64 %20, 12
%18-ty:i32  ;%18 = urem i32 %14, %17

## SREM
%25-ty:i32  ;%25 = srem i32 %24, 10
%30-ty:i32  ;%30 = srem i32 %28, %29
%11-ty:i64  ;%11 = srem i64 %10, 10
%38-ty:i32  ;%38 = srem i32 %36, %37
%49-ty:i64  ;%49 = srem i64 %47, %48
%26-ty:i64  ;%26 = srem i64 %24, %25
%6-ty:i32   ;%6 = srem i32 %5, 2
%25-ty:i64  ;%25 = srem i64 %24, 1000000007

## FREM (not found)
%X-ty:float    ;%X = frem float 4.0, %var

#### BITWISE BINARY OP

## SHL
%7-ty:i32           ;%7 = shl i32 %5, %6
%27-ty:i64          ;%27 = shl i64 %26, 1
%result-ty:i32      ;%result = shl i32 4, %var   ; yields i32: 4 << %var
%result-ty:i32      ;%result = shl i32 4, 2      ; yields i32: 16
%result-ty:i32      ;%result = shl i32 1, 10     ; yields i32: 1024
%result-ty:i32      ;%result = shl i32 1, 32     ; undefined
%result-ty:<2xi32>      ;%result = shl <2 x i32> < i32 1, i32 1>, < i32 1, i32 2>   ; yields: result=<2 x i32> < i32 2, i32 4>

## LSHR (not found)
%result-ty:i32  ;%result = lshr i32 4, 1   ; yields i32:result = 2
%result-ty:i32  ;%result = lshr i32 4, 2   ; yields i32:result = 1
%result-ty:i8   ;%result = lshr i8  4, 3   ; yields i8:result = 0
%result-ty:i8   ;%result = lshr i8 -2, 1   ; yields i8:result = 0x7F
%result-ty:i32      ;%result = lshr i32 1, 32  ; undefined
%result-ty:<2xi32>  ;%result = lshr <2 x i32> < i32 -2, i32 4>, < i32 1, i32 2>   ; yields: result=<2 x i32> < i32 0x7FFFFFFF, i32 1>

## ASHR
%14-ty:i32        ;%14 = ashr i32 %12, %13
%25-ty:i64        ;%25 = ashr i64 %24, 1
%result-ty:i32        ;%result = ashr i32 4, 1   ; yields i32:result = 2
%result-ty:i32        ;%result = ashr i32 4, 2   ; yields i32:result = 1
%result-ty:i8        ;%result = ashr i8  4, 3   ; yields i8:result = 0
%result-ty:i8        ;%result = ashr i8 -2, 1   ; yields i8:result = -1
%result-ty:i32        ;%result = ashr i32 1, 32  ; undefined
%result-ty:<2xi32>        ;%result = ashr <2 x i32> < i32 -2, i32 4>, < i32 1, i32 3>   ; yields: result=<2 x i32> < i32 -1, i32 0>

## AND
%7-ty:i32       ;%7 = and i32 %5, %6
%8-ty:i32       ;%8 = and i32 %7, %6
%16-ty:i32      ;%16 = and i32 %15, 1

## OR (not found)
%result-ty:i32  ;%result = or i32 4, %var         ; yields i32:result = 4 | %var
%result-ty:i32  ;%result = or i32 15, 40          ; yields i32:result = 47
%result-ty:i32  ;%result = or i32 4, 8            ; yields i32:result = 12

## XOR
%5-ty:i32       ;%5 = xor i32 %4, -1
%25-ty:i32      ;%25 = xor i32 %18, %24
%8-ty:i32       ;%8 = xor i32 %6, %7
%11-ty:i32      ;%11 = xor i32 %9, %10
%14-ty:i32      ;%14 = xor i32 %12, %13
%result-ty:i32      ;%result = xor i32 4, %var         ; yields i32:result = 4 ^ %var
%result-ty:i32      ;%result = xor i32 15, 40          ; yields i32:result = 39
%result-ty:i32      ;%result = xor i32 4, 8            ; yields i32:result = 12
%result-ty:i32      ;%result = xor i32 %V, -1          ; yields i32:result = ~%V

#### VECTOR OP

## EXTRACTELEMENT (not found)
%result-ty:i32      ;%result = extractelement <4 x i32> %vec, i32 0    ; yields i32

## INSERTELEMENT (not found)
%result-ty:<4xi32>  ;%result = insertelement <4 x i32> %vec, i32 1, i32 0    ; yields <4 x i32>

## SHUFFLEVECTOR (not found)
%result-ty:<4xi32>     ;%result = shufflevector <4 x i32> %v1, <4 x i32> %v2, <4 x i32> <i32 0, i32 4, i32 1, i32 5>  ; yields <4 x i32>
%result-ty:<4xi32>     ;%result = shufflevector <4 x i32> %v1, <4 x i32> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>  ; yields <4 x i32> - Identity shuffle.
%result-ty:<4xi32>     ;%result = shufflevector <8 x i32> %v1, <8 x i32> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>  ; yields <4 x i32>
%result-ty:<8xi32>     ;%result = shufflevector <4 x i32> %v1, <4 x i32> %v2, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7 >  ; yields <8 x i32>

#### AGGREGATE OP

## EXTRACTVALUE (not found) # TODO: this is a placeholder
%result-ty:i32	;%result = extractvalue {i32, float} %agg, 0    ; yields i32

## INSERTVALUE (not found) # TODO: this is a placeholder
%agg1-ty:{i32,float}		;%agg1 = insertvalue {i32, float} undef, i32 1, 0              ; yields {i32 1, float undef}
%agg2-ty:{i32,float}		;%agg2 = insertvalue {i32, float} %agg1, float %val, 1         ; yields {i32 1, float %val}
%agg3-ty:{i32,{float}}		;%agg3 = insertvalue {i32, {float}} undef, float %val, 1, 0    ; yields {i32 undef, {float %val}}

#### MEMORY ACCESS AND ADDRESSING OP

## ALLOCA
%1-ty:i32*      ;%1 = alloca i32, align 4
%4-ty:double*      ;%4 = alloca double, align 8
%6-ty:i32*      ;%6 = alloca i32, align 4
%7-ty:double*      ;%7 = alloca double, align 8
%2-ty:float*      ;%2 = alloca float, align 4
%3-ty:float*      ;%3 = alloca float, align 4
%7-ty:%struct.rect*      ;%7 = alloca %struct.rect, align 4
%8-ty:%struct.rect*      ;%8 = alloca %struct.rect, align 4
%4-ty:i8*      ;%4 = alloca i8, align 1
%7-ty:i8*      ;%7 = alloca i8, align 1
%4-ty:i32**      ;%4 = alloca i32*, align 8
%5-ty:i32**      ;%5 = alloca i32*, align 8
%8-ty:[10xi32]*      ;%8 = alloca [10 x i32], align 16
%2-ty:[6xi32]*      ;%2 = alloca [6 x i32], align 16
%2-ty:double*      ;%2 = alloca double, align 8
%3-ty:double*      ;%3 = alloca double, align 8
%4-ty:float*      ;%4 = alloca float, align 4
%13-ty:i32*     ;%13 = alloca i32, i64 %11, align 16
%16-ty:i32*     ;%16 = alloca i32, i64 %15, align 16
%2-ty:[20xi8]*      ;%2 = alloca [20 x i8], align 16
%6-ty:i8***      ;%6 = alloca i8**, align 8
%7-ty:i8***      ;%7 = alloca i8**, align 8
%5-ty:i8***      ;%5 = alloca i8**, align 8
%2-ty:[100xi8]*      ;%2 = alloca [100 x i8], align 16
%1-ty:[20x[20xi8]]*      ;%1 = alloca [20 x [20 x i8]], align 16
%2-ty:%struct.lcg_rand**      ;%2 = alloca %struct.lcg_rand*, align 8
%3-ty:%struct.node**      ;%3 = alloca %struct.node*, align 8
%6-ty:i32**      ;%6 = alloca i32*, align 8
%3-ty:%struct.task*      ;%3 = alloca %struct.task, align 4
%4-ty:%struct.task**      ;%4 = alloca %struct.task*, align 8
%2-ty:%struct.task***      ;%2 = alloca %struct.task**, align 8

## LOAD
%16-ty:i32         ;%16 = load i32, i32* %4, align 4
%8-ty:i32          ;%8 = load i32, i32* %5, align 4
%10-ty:i32         ;%10 = load i32, i32* %6, align 4
%13-ty:double         ;%13 = load double, double* %4, align 8
%24-ty:double         ;%24 = load double, double* %3, align 8
%7-ty:float          ;%7 = load float, float* %2, align 4
%10-ty:float         ;%10 = load float, float* %2, align 4
%3-ty:i32          ;%3 = load i32, i32* @position, align 4
%14-ty:i32         ;%14 = load i32, i32* @n, align 4
%8-ty:i8          ;%8 = load i8, i8* %7, align 1
%16-ty:i8         ;%16 = load i8, i8* %7, align 1
%21-ty:float         ;%21 = load float, float* %11, align 4
%22-ty:float         ;%22 = load float, float* %12, align 4
%20-ty:i32*         ;%20 = load i32*, i32** %5, align 8
%27-ty:i32*         ;%27 = load i32*, i32** %7, align 8
%15-ty:i8*         ;%15 = load i8*, i8** %11, align 8
%8-ty:%struct._IO_FILE*          ;%8 = load %struct._IO_FILE*, %struct._IO_FILE** @stdin, align 8
%24-ty:i64         ;%24 = load i64, i64* %2, align 8
%26-ty:i64          ;%26 = load i64, i64* %2, align 8
%80-ty:i8*         ;%80 = load i8*, i8** %5, align 8
%58-ty:i64*         ;%58 = load i64*, i64** %8, align 8
%18-ty:i8**         ;%18 = load i8**, i8*** %7, align 8
%50-ty:i16          ;%50 = load i16, i16* %5, align 2
%4-ty:%struct.lcg_rand*          ;%4 = load %struct.lcg_rand*, %struct.lcg_rand** %2, align 8
%1-ty:%struct.node*          ;%1 = load %struct.node*, %struct.node** @first, align 8
%24-ty:%struct.node*         ;%24 = load %struct.node*, %struct.node** @head, align 8
%27-ty:[3xi32]*         ;%27 = load [3 x i32]*, [3 x i32]** %6, align 8
%48-ty:[3xi32]*         ;%48 = load [3 x i32]*, [3 x i32]** %6, align 8
%12-ty:i32         ;%12 = load i32, i32* getelementptr inbounds (%struct.student, %struct.student* @s, i32 0, i32 1), align 4
%14-ty:float         ;%14 = load float, float* getelementptr inbounds (%struct.student, %struct.student* @s, i32 0, i32 2), align 4

## STORE
;store i32 0, i32* %1, align 44
;store double %0, double* %4, align 8
;store i32 0, i32* %1, align 4
;store float %17, float* %4, align 4
;store i32 20, i32* @choice, align 4
;store i8* %0, i8** %3, align 8
;store i32 10, i32* getelementptr inbounds ([5 x %struct.rect], [5 x %struct.rect]* @r, i64 0, i64 0, i32 0), align 16
;store i32 2, i32* getelementptr inbounds ([5 x %struct.rect], [5 x %struct.rect]* @r, i64 0, i64 0, i32 1), align 4
;store i8 %2, i8* %7, align 1
;store i32* %5, i32** %12, align 8
;store double %7, double* %3, align 8
;store i64 %25, i64* %5, align 8
;store float 0.000000e+00, float* %3, align 4
;store float 0.000000e+00, float* %4, align 4
;store i8* %12, i8** %5, align 8
;store i8** %1, i8*** %6, align 8
;store i8** %2, i8*** %7, align 8
;store i16 %72, i16* %74, align 2
;store i16 %77, i16* %79, align 2
;store %struct.lcg_rand* %0, %struct.lcg_rand** %2, align 8
;store %struct.node* %15, %struct.node** @tail, align 8
;store i32 %8, i32* @printFibonacci.n3, align 4
;store %struct.Node* null, %struct.Node** %2, align 8
;store %struct.task* %2, %struct.task** %6, align 8
;store i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i32 0, i32 0), i8** %2, align 8
;store [3 x i32]* %2, [3 x i32]** %6, align 8
;store double 1.000000e+00, double* %3, align 8

## FENCE (not found)

;fence acquire                                        ; yields void
;fence syncscope("singlethread") seq_cst              ; yields void
;fence syncscope("agent") seq_cst                     ; yields void

## CMPXCHG (not found)
# Same as 'invoke'.
#%val_success = cmpxchg i32* %ptr, i32 %cmp, i32 %squared acq_rel monotonic ; yields  { i32, i1 }
;cmpxchg i32* %ptr, i32 %cmp, i32 %squared acq_rel monotonic ; yields  { i32, i1 }

## ATOMICRMW (not found)
#Same as 'invoke'.
#%old = atomicrmw add i32* %ptr, i32 1 acquire                        ; yields i32
;atomicrmw add i32* %ptr, i32 1 acquire                        ; yields i32

## GETELEMENTPTR    # TODO: this is a placeholder
%22-ty:[100xi32]-field-ptr			;%22 = getelementptr inbounds [100 x i32], [100 x i32]* @arr, i64 0, i64 %21
%9-ty:i32-field-ptr			;%9 = getelementptr inbounds i32, i32* getelementptr inbounds ([100 x i32], [100 x i32]* @arr, i32 0, i32 0), i64 %8
%14-ty:[5x%struct.rect]-field-ptr			;%14 = getelementptr inbounds [5 x %struct.rect], [5 x %struct.rect]* @r, i64 0, i64 %13
%16-ty:[20x[20xi8]]-field-ptr			;%16 = getelementptr inbounds [20 x [20 x i8]], [20 x [20 x i8]]* %1, i64 0, i64 %15
%17-ty:[20xi8]-field-ptr			;%17 = getelementptr inbounds [20 x i8], [20 x i8]* %16, i32 0, i32 0
%39-ty:[20x[20xi8]]-field-ptr			;%39 = getelementptr inbounds [20 x [20 x i8]], [20 x [20 x i8]]* %1, i64 0, i64 %38
%14-ty:[2000001xi64]-field-ptr			;%14 = getelementptr inbounds [2000001 x i64], [2000001 x i64]* bitcast (<{ i64, [2000000 x i64] }>* @fact to [2000001 x i64]*), i64 0, i64 %13
%27-ty:i8-field-ptr			;%27 = getelementptr inbounds i8, i8* %9, i64 %26
%14-ty:i32-field-ptr			;%14 = getelementptr inbounds i32, i32* %12, i64 %13
%38-ty:%struct.task-field-ptr			;%38 = getelementptr inbounds %struct.task, %struct.task* %3, i32 0, i32 0
%9-ty:%struct.task-field-ptr			;%9 = getelementptr inbounds %struct.task, %struct.task* %6, i64 %8
%10-ty:%struct.task-field-ptr			;%10 = getelementptr inbounds %struct.task, %struct.task* %9, i64 0
%21-ty:[50xi32]-field-ptr			;%21 = getelementptr inbounds [50 x i32], [50 x i32]* %2, i32 0, i32 0
%32-ty:[50xi32]-field-ptr			;%32 = getelementptr inbounds [50 x i32], [50 x i32]* %2, i64 0, i64 %31
%11-ty:i8-field-ptr			;%11 = getelementptr inbounds i8, i8* %10, i64 2
%25-ty:i32-field-ptr			;%25 = getelementptr inbounds i32, i32* %22, i64 %24
%27-ty:[10x[10xi32]]-field-ptr			;%27 = getelementptr inbounds [10 x [10 x i32]], [10 x [10 x i32]]* %6, i64 0, i64 %26
%4-ty:[4x[3xi32]]-field-ptr		;%4 = getelementptr inbounds [4 x [3 x i32]], [4 x [3 x i32]]* %2, i32 0, i32 0
%8-ty:i8-field-ptr	;%8 = getelementptr inbounds i8, i8* %5, i64 %7
%5-ty:[100xi8]-field-ptr			;%5 = getelementptr inbounds [100 x i8], [100 x i8]* %3, i32 0, i32 0
%69-ty:[10xi8]-field-ptr			;%69 = getelementptr inbounds [10 x i8], [10 x i8]* %6, i32 0, i32 0
%aptr-ty:{i32,[12xi8]}-field-ptr			;%aptr = getelementptr {i32, [12 x i8]}, {i32, [12 x i8]}* %saptr, i64 0, i32 1 ; yields [12 x i8]*:aptr
%vptr-ty:{i32,<2xi8>}-field-ptr			;%vptr = getelementptr {i32, <2 x i8>}, {i32, <2 x i8>}* %svptr, i64 0, i32 1, i32 1 ; yields i8*:vptr
%eptr-ty:[12xi8]-field-ptr			;%eptr = getelementptr [12 x i8], [12 x i8]* %aptr, i64 0, i32 1 ; yields i8*:eptr
%iptr-ty:[10xi32]-field-ptr			;%iptr = getelementptr [10 x i32], [10 x i32]* @arr, i16 0, i16 0 ; yields i32*:iptr

## CONVERSION OP
%2-ty:i32      ;%2 = trunc i64 %1 to i32
%47-ty:i8     ;%47 = trunc i32 %46 to i8
%30-ty:i64     ;%30 = zext i1 %29 to i64
%18-ty:i64     ;%18 = zext i32 %17 to i64
%19-ty:i32     ;%19 = zext i16 %18 to i32
%108-ty:i64    ;%108 = sext i32 %107 to i64
%11-ty:i32     ;%11 = sext i8 %10 to i32
%6-ty:i32      ;%6 = sext i8 %5 to i32
%13-ty:float     ;%13 = fptrunc double %12 to float
%17-ty:float     ;%17 = fptrunc double %16 to float
%X-ty:float      ;%X = fptrunc double 16777217.0 to float    ; yields float:16777216.0
%8-ty:double      ;%8 = fpext float %7 to double
%11-ty:double     ;%11 = fpext float %10 to double
%X-ty:double      ;%X = fpext float 3.125 to double         ; yields double:3.125000e+00
%Y-ty:fp128      ;%Y = fpext double %X to fp128            ; yields fp128:0xL00000000000000004000900000000000
%5-ty:i32      ;%5 = fptoui double %4 to i32
%X-ty:i32      ;%X = fptoui double 123.0 to i32      ; yields i32:123
%Y-ty:i1      ;%Y = fptoui float 1.0E+300 to i1     ; yields undefined:1
%Z-ty:i8      ;%Z = fptoui float 1.04E+17 to i8     ; yields undefined:1
%31-ty:i32     ;%31 = fptosi double %30 to i32
%8-ty:i32      ;%8 = fptosi float %7 to i32
%X-ty:i32      ;%X = fptosi double -123.0 to i32      ; yields i32:-123
%Y-ty:i1      ;%Y = fptosi float 1.0E-247 to i1      ; yields undefined:1
%Z-ty:i8      ;%Z = fptosi float 1.04E+17 to i8      ; yields undefined:1
%15-ty:float     ;%15 = uitofp i32 %14 to float
%X-ty:float      ;%X = uitofp i32 257 to float         ; yields float:257.0
%Y-ty:double      ;%Y = uitofp i8 -1 to double          ; yields double:255.0
%27-ty:double     ;%27 = sitofp i32 %26 to double
%20-ty:float     ;%20 = sitofp i32 %19 to float
%12-ty:double     ;%12 = sitofp i64 %11 to double
%X-ty:float      ;%X = sitofp i32 257 to float         ; yields float:257.0
%Y-ty:double      ;%Y = sitofp i8 -1 to double          ; yields double:-1.0
%X-ty:i8      ;%X = ptrtoint i32* %P to i8                         ; yields truncation on 32-bit architecture
%Y-ty:i64      ;%Y = ptrtoint i32* %P to i64                        ; yields zero extension on 32-bit architecture
%Z-ty:<4xi64>      ;%Z = ptrtoint <4 x i32*> %P to <4 x i64>; yields vector zero extension for a vector of addresses on 32-bit architecture
%X-ty:i32*      ;%X = inttoptr i32 255 to i32*          ; yields zero extension on 64-bit architecture
%Y-ty:i32*      ;%Y = inttoptr i32 255 to i32*          ; yields no-op on 32-bit architecture
%Z-ty:i32*      ;%Z = inttoptr i64 0 to i32*            ; yields truncation on 32-bit architecture
%Z-ty:<4xi8*>      ;%Z = inttoptr <4 x i32> %G to <4 x i8*>; yields truncation of vector G to four pointers
%10-ty:%struct.rect*     ;%10 = bitcast i8* %9 to %struct.rect*
%11-ty:i8*     ;%11 = bitcast %struct.rect* %7 to i8*
%4-ty:i8*     ;%4 = bitcast [6 x i32]* %2 to i8*
%3-ty:i8*     ;%3 = bitcast [156 x i8]* %2 to i8*
%4-ty:i8*     ;%4 = bitcast i32* %2 to i8*
%7-ty:i32*      ;%7 = bitcast i8* %6 to i32*
%16-ty:%struct.task*     ;%16 = bitcast i8* %15 to %struct.task*
%3-ty:i8*      ;%3 = bitcast [4 x [3 x i32]]* %2 to i8*
%X-ty:i8      ;%X = bitcast i8 255 to i8              ; yields i8 :-1
# From docs. Not working.
#%Y = bitcast i32* %x to sint*          ; yields sint*:%x
#%Z = bitcast <2 x int> %V to i64;        ; yields i64: %V
%Z-ty:<2xi64*> ;%Z = bitcast <2 x i32*> %V to <2 x i64*> ; yields <2 x i64*>
%X-ty:i32addrspace(1)* ;%X = addrspacecast i32* %x to i32 addrspace(1)*    ; yields i32 addrspace(1)*:%x
%Y-ty:i64addrspace(2)* ;%Y = addrspacecast i32 addrspace(1)* %y to i64 addrspace(2)*    ; yields i64 addrspace(2)*:%y
%Z-ty:<4xfloataddrspace(3)*> ;%Z = addrspacecast <4 x i32*> %z to <4 x float addrspace(3)*>   ; yields <4 x float addrspace(3)*>:%z

#### OTHER OP

## ICMP
%12-ty:i1       ;%12 = icmp ult i32 %11, 10
%12-ty:<4xi1>   ;%12 = icmp ult <4xi32> %11, %10 ; invented
%9-ty:i1        ;%9 = icmp sgt i64 %7, %8
%16-ty:i1       ;%16 = icmp ne %struct.node* %15, null
%31-ty:i1       ;%31 = icmp sle i32 %27, %30
%11-ty:i1       ;%11 = icmp slt i32 %9, %10
%23-ty:i1       ;%23 = icmp eq %struct.Node* %22, null
%8-ty:i1        ;%8 = icmp ne %struct.Node* %7, null
%8-ty:i1        ;%8 = icmp ne i32 %7, 0
%85-ty:i1       ;%85 = icmp sgt i32 %80, %84
%94-ty:i1       ;%94 = icmp slt i32 %92, %93
%101-ty:i1      ;%101 = icmp sge i32 %99, %10
%15-ty:i1       ;%15 = icmp sle i32 %13, %14
%46-ty:i1       ;%46 = icmp eq i32 %45, 0
%71-ty:i1       ;%71 = icmp eq i32 %70, 0
%result-ty:i1       ;%result = icmp eq i32 4, 5          ; yields: result=false
%result-ty:i1       ;%result = icmp ne float* %X, %X     ; yields: result=false
%result-ty:i1       ;%result = icmp ult i16  4, 5        ; yields: result=true
%result-ty:i1       ;%result = icmp sgt i16  4, 5        ; yields: result=false
%result-ty:i1       ;%result = icmp ule i16 -4, 5        ; yields: result=false
%result-ty:i1       ;%result = icmp sge i16  4, 5        ; yields: result=false

## FCMP
%60-ty:i1        ;%60 = fcmp oeq float %59, 0.000000e+00
%29-ty:i1        ;%29 = fcmp oge float %28, 1.000000e+05
%37-ty:i1        ;%37 = fcmp olt float %36, 1.000000e+05
%42-ty:i1        ;%42 = fcmp oge float %41, 5.000000e+04
%12-ty:i1        ;%12 = fcmp ogt double %11, 0x3E7AD7F29ABCAF48
%12-ty:i1        ;%12 = fcmp ogt double %11, 0x3E7AD7F29ABCAF48
%10-ty:i1        ;%10 = fcmp ogt float %8, %9
%result-ty:i1        ;%result = fcmp oeq float 4.0, 5.0    ; yields: result=false
%result-ty:i1        ;%result = fcmp one float 4.0, 5.0    ; yields: result=true
%result-ty:i1        ;%result = fcmp olt float 4.0, 5.0    ; yields: result=true
%result-ty:i1        ;%result = fcmp ueq double 1.0, 2.0   ; yields: result=false

## PHI
%45-ty:i1        ;%45 = phi i1 [ false, %36 ], [ false, %32 ], [ false, %28 ], [ %43, %40 ]
%28-ty:i1        ;%28 = phi i1 [ true, %19 ], [ %26, %23 ]
%16-ty:i32       ;%16 = phi i32 [ %12, %11 ], [ %14, %13 ]
%32-ty:float         ;%32 = phi float [ %20, %19 ], [ %30, %29 ]

## SELECT
%31-ty:i32 ;%31 = select i1 %29, i32 1, i32 0
%23-ty:i32 ;%23 = select i1 %21, i32 0, i32 1
%X-ty:i8 ;%X = select i1 true, i8 17, i8 42          ; yields i8:17

## CALL
%25-ty:double ;%25 = call double @convertTemp(double %24, i32 1, i32 1)
			;call void @menu()
%1-ty:i32     ;%1 = call i32 @bubble_sort_algo()
			;call void @exit(i32 1) #3
%12-ty:i32        ;%12 = call i32 @main()
			;call void @linear_search()
			;call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %11, i8* align 4 %12, i64 8, i1 false)
			;call void @qsort(i8* bitcast ([5 x %struct.rect]* @r to i8*), i64 5, i64 8, i32 (i8*, i8*)* @area_comp)
%27-ty:i32        ;%27 = call i32 @pthread_mutex_unlock(%union.pthread_mutex_t* @lock) #4
%28-ty:i32        ;%28 = call i32 @sleep(i32 10)
%1-ty:i64     ;%1 = call i64 @time(i64* null) #4
			;call void @srand(i32 %2) #4
%19-ty:i32        ;%19 = call i32 @getRandom(i32 0, i32 %18)
			;call void @secondLine(i32 %54, i32 %55, i32 %56, i8 signext %57)
%28-ty:i32        ;%28 = call i32 (i8*, i32*, ...) bitcast (i32 (...)* @scanf_s to i32 (i8*, i32*, ...)*)(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.9, i32 0, i32 0), i32* %11)
%20-ty:i8*        ;%20 = call noalias i8* @malloc(i64 %19) #3
%9-ty:i32     ;%9 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.1, i32 0, i32 0), i32 %8)
%14-ty:i64        ;%14 = call i64 @time(i64* null) #3
			;call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %51, i8* align 4 %52, i64 8, i1 false)
			;call void @spiral_matrix(i32 4, i32 3, [3 x i32]* %4)
%11-ty:double        ;%11 = call double @llvm.fabs.f64(double %10)
%3-ty:i32     ;%3 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i32 0, i32 0), i32* %2)
%5-ty:double     ;%5 = call double @squareRoot(i32 %4)
%6-ty:i32     ;%6 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.1, i32 0, i32 0), double %5)
%11-ty:double        ;%11 = call double @llvm.fabs.f64(double %10)
%3-ty:i32     ;%3 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i32 0, i32 0), i32* %2)
%5-ty:double     ;%5 = call double @squareRoot(i32 %4)
%6-ty:i32     ;%6 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i32 0, i32 0), i8* %5)
%9-ty:i32     ;%9 = call i32 @stringLength(i8* %8)
%11-ty:i32        ;%11 = call i32 @puts(i8* getelementptr inbounds (%struct.student, %struct.student* @s, i32 0, i32 0, i32 0))
%10-ty:i32        ;%10 = call i32 (i8*, ...) @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i32 0, i32 0), i8* %9)
%34-ty:double        ;%34 = call double @sqrt(double %33) #5
%45-ty:i32        ;%45 = call i32 @strcmp(i8* %44, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.5, i32 0, i32 0)) #4
%81-ty:double        ;%81 = call double @pow(double %80, double 2.000000e+00) #5
%10-ty:i32        ;%10 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.3, i32 0, i32 0))
%retval-ty:i32        ;%retval = call i32 @test(i32 %argc)
			;call i32 (i8*, ...)* @printf(i8* %msg, i32 12, i8 42)        ; yields i32
%X-ty:i32     ;%X = tail call i32 @foo()                                    ; yields i32
%Y-ty:i32     ;%Y = tail call fastcc i32 @foo()  ; yields i32
# From docs. Not working.
#call void %foo(i8 97 signext)
%r-ty:%struct.A     ;%r = call %struct.A @foo()                        ; yields { i32, i8 }
%Z-ty:void     ;%Z = call void @foo() noreturn                    ; indicates that %foo never returns normally
%ZZ-ty:i32        ;%ZZ = call zeroext i32 @bar()                     ; Return value is %zero extended

## VA_ARG (not found)
%tmp-ty:i32 ;%tmp = va_arg i8* %ap2, i32

## LANDINGPAD (not found)
%res-ty:{i8*,i32} ;%res = landingpad { i8*, i32 } catch i8** @_ZTIi ;; A landing pad which can catch an integer.
%res-ty:{i8*,i32} ;%res = landingpad { i8*, i32 } cleanup ;; A landing pad that is a cleanup.
# From docs. Not working.
#%res = landingpad { i8*, i32 } catch i8** @_ZTIi filter [1 x i8**] [@_ZTId] ;; A landing pad which can catch an integer and can only throw a double.
# Not working.
#%0 = landingpad { i8*, i32 } filter [0 x i8*] zeroinitializer

## CATCHPAD (not found)
%tok-ty:token   ;%tok = catchpad within %cs [i8** @_ZTIi]

## CLEANUPPAD (not found)
%tok-ty:token   ;%tok = cleanuppad within %cs []
