import pytest
from ccpt.cfg_to_trie.iv_old import parse
from typing import Set

# From old file: may be useful if path errors occur in the future.
# sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__),
#                 '..')))
# IV_IN_DAT = os.path.join(os.path.dirname(__file__), 'in_iv_old.dat')
# IV_OUT_DAT = os.path.join(os.path.dirname(__file__), 'out_iv_old.dat')


class TestInstructionVisitor():

    def test_return_type(self):
        t = parse('%3 = load i32, i32* %j, align 4')
        assert isinstance(t, Set)

    def test_load(self):
        t = parse('%3 = load i32, i32* %j, align 4')
        tt = {('write', '%3'), ('read', '%j'), ('op', 'load'), ('%3', 'i32')}
        assert t == tt

    def test_empty_inst(self):
        with pytest.raises(Exception):
            parse('')

    def test_wrong_inst(self):
        with pytest.raises(Exception):
            parse('abcdefghi')

    def test_parse_dat(self):
        """
        Test if all instructions in in_iv_old.dat are parsed without any error.
        """
        with open("tests/data/in_iv_old.dat", 'r') as file_in:
            while True:
                line = file_in.readline()
                if not line:
                    break
                t = parse(line)
                assert isinstance(t, set)

    def test_subset_from_dat(self):
        '''
        Test if what is generated by IV is not wrong: that means generated
        subset of expected.
        '''

        with open("tests/data/in_iv_old.dat", 'r') as file_in, \
                open("tests/data/out_iv_old.dat", 'r') as file_out:
            while True:
                line = file_in.readline()
                line_out = file_out.readline()
                if not line or not line_out:
                    break

                t_expected = set()
                for i in line_out.rstrip().split(' '):
                    j = i.split(':')
                    t_expected.add((str(j[0]), str(j[1])))

                t = parse(line)
                # Check return type.
                assert isinstance(t, Set)
                # Check if generated is subset of expected.
                assert t.issubset(t_expected), \
                    'From: ' + line + '\nGot: ' + str(t) \
                    + '\nExp: ' + str(t_expected)

    def test_equal_from_dat(self):
        '''
        Test if what is generated by IV is EQUAL to what is expected.
        '''

        with open("tests/data/in_iv_old.dat", 'r') as file_in, \
                open("tests/data/out_iv_old.dat", 'r') as file_out:
            while True:
                line = file_in.readline()
                line_out = file_out.readline()
                if not line or not line_out:
                    break

                t_expected = set()
                for i in line_out.rstrip().split(' '):
                    j = i.split(':')
                    t_expected.add((str(j[0]), str(j[1])))

                t = parse(line)
                # Check return type.
                assert isinstance(t, Set)
                # Check if generated is equal to expected.
                assert t == t_expected, \
                    '\nFrom: ' + line + 'Got: ' + str(t) \
                    + '\nExp: ' + str(t_expected)
