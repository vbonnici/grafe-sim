import argparse
import logging
import os
import pathlib
import ccpt.cfg_to_trie.gencfg as gencfg
from ccpt.cfg_to_trie.gentrie import Trie
import ccpt.cfg_to_trie.utils as utils
import networkx as nx
import time



logger = logging.getLogger(__name__)
logger.addHandler(logging.NullHandler())


def preprocess_ll() -> None:
    """
    CLI entry-point for pre-processing step: takes a C/C++ source code
    file as input and generates a .ll file containing LLVMIR got from
    clang/clang++.
    """

    logging.config.fileConfig(
        os.path.join(os.path.dirname(__file__), "../../../log.config"),
        disable_existing_loggers=False)

    # CLI.
    parser = argparse.ArgumentParser()
    parser.add_argument("file", type=argparse.FileType('r'),
                        help="input file (C or C++ source)")
    parser.add_argument("-cpp", "--use-clang-cpp", action="store_true",
                        default=False,
                        help="use clang++ instead of clang")
    parser.add_argument("-o", "--output", type=str, metavar="OUT_FILENAME",
                        default="",
                        help="output LLVMIR file name")
    args = parser.parse_args()
    in_file_name = args.file.name
    out_file_name = args.output
    cpp_flag = args.use_clang_cpp

    # Get LLVM-IR using Clang/Clang++.
    print("Getting LLVMIR using clang" + ("++" if cpp_flag else "") + "-7...")
    try:
        start_counter_ns = time.perf_counter_ns()
        llvmir_str = utils.c_to_ll(in_file_name, cpp_flag)
        end_counter_ns = time.perf_counter_ns()

        timer_ns = end_counter_ns - start_counter_ns

        print("#### GENLL (ms): ", timer_ns/1e6)
    except RuntimeError:
        print("Got an exception executing c_to_ll().")
        raise
    print("Done.")

    # Print output file in current directory.
    if not out_file_name:
        out_file_name = pathlib.Path(in_file_name).stem + ".ll"
    print(f"Printing LLVMIR in '{out_file_name}' file...")
    with open(out_file_name, "w") as fout:
        fout.write(llvmir_str)
    print("Done.")

    return


def preprocess() -> None:
    '''
    Temporary.

    This is the "main" function for preprocess step: takes a C/C++
    source file as input and produces with clang the .ll file and
    a the CFG of specified function (if more than one).

    '''

    logging.config.fileConfig(
        os.path.join(os.path.dirname(__file__), "../../../log.config"),
        disable_existing_loggers=False)

    # TODO: think about temporary files generated (CFGs).

    parser = argparse.ArgumentParser()
    parser.add_argument("file", type=argparse.FileType('r'),
                        help="input file (C or C++ source)")
    # Non-positional options.
    parser.add_argument("-f", "--function", type=str, metavar="FUNCTION_NAME",
                        default="",
                        help="fuction name")
    parser.add_argument("-kl", "--keep-llvm", action="store_true",
                        default=False,
                        help="keep llvm-ir file")

    args = parser.parse_args()
    function_name = args.function
    file_name = args.file.name
    llvmir_flag = args.keep_llvm

    # Generate CLANG CFG.
    dict = utils.c_to_nx(file_name, llvmir_flag)
    if len(dict) == 0:
        print("No CFG generated by clang.")
        exit(1)

    # Must specify function name if more than one function was found.
    if len(dict) > 1:
        if function_name == "" or not dict[function_name]:
            print("Found more than one function: you must specify a "
                  + "valid function name")
            exit(1)
        else:
            dict = {function_name: dict[function_name]}

    # Get the only item in the dictionary.
    name, G = list(dict.items())[0]

    # Output dot file.
    nx.nx_pydot.write_dot(G, f"cfg.{name}.dot")
    print(f"Clang CFG written in 'cfg.{name}.dot'.")

    return


def main() -> None:

    logging.config.fileConfig(
        os.path.join(os.path.dirname(__file__), "../../../log.config"),
        disable_existing_loggers=False)

    default_mapping = os.path.join(os.path.dirname(__file__),
                                   "../../../../classes/map0.csv")
    # CLI arguments parsing.

    parser = argparse.ArgumentParser()
    # Positional options.
    parser.add_argument("file", type=argparse.FileType('r'), nargs='+',
                        help="input file (C or C++ source)")
    # Non-positional options.
    parser.add_argument("-f", "--function", type=str, metavar="FUNCTION_NAME",
                        default="",
                        help="fuction name")
    parser.add_argument("-m", "--mapping", type=str, metavar="CSV_FILE",
                        default=default_mapping,
                        help="csv mapping file")
    parser.add_argument("-lp", "--length-path", type=int,
                        default=3,
                        help="set max DFS depth to LP (GraphGrepSX)")
    # Flags.
    parser.add_argument("-nv", "--no-var", action="store_true",
                        default=False,
                        help="do not generate variables subgraph")
    parser.add_argument("-nc", "--no-const", action="store_true",
                        default=False,
                        help="do not generate constants subgraph")
    parser.add_argument("--emit-trie-pdf", action="store_true",
                        default=False,
                        help="print cfg in pdf format")
    parser.add_argument("--emit-cfg-pdf", action="store_true",
                        default=False,
                        help="print trie in pdf format")
    # parser.add_argument("--out-cfg", type=str,
    #                     default="out-cfg.dot",
    #                     help="filename of output cfg")
    # parser.add_argument("--out-trie", type=str,
    #                     default="out-trie.dot",
    #                     help="filename of output trie")
    parser.add_argument("-kl", "--keep-llvm", action="store_true",
                        default=False,
                        help="keep llvm-ir file")

    args = parser.parse_args()

    function_name = args.function
    in_mapping = args.mapping
    lp = args.length_path
    var_flag = not args.no_var
    const_flag = not args.no_const
    cfg_pdf_flag = args.emit_cfg_pdf
    trie_pdf_flag = args.emit_trie_pdf
    # out_cfg = args.out_cfg
    # out_trie = args.out_trie
    llvmir_flag = args.keep_llvm

    print("CCPT: C -> CFG -> A-CFG -> A-CFG-TRIE")
    print("-------------------------------------")

    # Print parameters.
    print("Parameters:")
    print(f"  Instruction mapping file: {in_mapping}")
    print(f"  Generate variables subgraph in A-CFG: {var_flag}")
    print(f"  Generate constants subgraph in A-CFG: {const_flag}")
    print(f"  GraphGrepSX path lenght: {lp}")
    print("--")

    # For each input file: .c -> .dot (trie).
    for fname in [f.name for f in args.file]:
        print(f"input file: {fname}")

        # Generate CLANG CFG.
        dict = utils.c_to_nx(fname, llvmir_flag)
        # Must have one function.
        if len(dict) == 0:
            print("No CFG generated by clang.")
            exit(1)
        if len(dict) > 1:
            if function_name == "" or not dict[function_name]:
                print("Found more than one function: you must specify a "
                      + "valid function name")
                exit(1)
            else:
                dict = {function_name: dict[function_name]}

        for k, v in dict.items():
            name = k
            G = v

        # Use input file name to generate filenames.
        s = os.path.basename(fname).rstrip(".c")
        s = s.rstrip(".cpp")
        out_cfg = s + "-cfg.dot"
        out_trie = s + "-trie.dot"
        cfg_pdf_fname = s + "-cfg.pdf"
        trie_pdf_fname = s + "-trie.pdf"

        # Read input dot -> G.
        # G = utils.dot_to_nx(in_dot)

        # Augment G -> A.
        map = gencfg.gen_map_from_csv(in_mapping)
        A = gencfg.augmenter(G, map, var_flag, const_flag)

        # Create trie of A -> T.
        T: Trie = Trie(A, lp)

        # Print A and T as .dot files.
        nx.nx_pydot.write_dot(A, out_cfg)
        print(f"Augmented CFG of {name} function in \"{out_cfg}\"")
        nx.nx_pydot.write_dot(T, out_trie)
        print(f"Trie of augmented CFG in \"{out_trie}\"")

        # Optional prints.
        if cfg_pdf_flag:
            utils.nx_to_pdf(A, cfg_pdf_fname)
            print(f"CFG printed in \"{cfg_pdf_fname}\".")
        if trie_pdf_flag:
            utils.nx_to_pdf(T, trie_pdf_fname)
            print(f"CFG TRIE printed in \"{trie_pdf_fname}\".")

        print("--")

    return


def main_new() -> None:

    logging.config.fileConfig(
        os.path.join(os.path.dirname(__file__), "../../../log.config"),
        disable_existing_loggers=False)

    # CLI arguments parsing.
    parser = argparse.ArgumentParser()

    # parser.add_argument("-e", "--extra-output", action="store_true",
    #                     default=False,
    #                     help="extra output: ?")
    parser.add_argument("-o", "--output", type=str, metavar="OUT_FILENAME",
                        default="",
                        help="output abstract cfg file name")

    # genll.
    parser.add_argument("file", type=argparse.FileType('r'),
                        help="input file (C or C++ source)")
    parser.add_argument("-cpp", "--use-clang-cpp", action="store_true",
                        default=False,
                        help="use clang++ instead of clang")
    # gencfg.
    parser.add_argument("-m", "--mapping", type=str, metavar="MAP",
                        default="3",
                        help="map-id [0-4] or csv file")
    parser.add_argument("-nv", "--no-var", action="store_true",
                        default=False,
                        help="do not generate variables subgraph")
    parser.add_argument("-nc", "--no-const", action="store_true",
                        default=False,
                        help="do not generate constants subgraph")
    parser.add_argument("-sty", "--simplified-types", action="store_true",
                        default=False,
                        help="use simplified types instead of RAW types.")
    parser.add_argument("-ncut", "--no-cut", action="store_true",
                        default=False,
                        help="do not 'clean' tree: \
                        e.g. removing unuseful terminators")
    parser.add_argument("-fn", "--function-name", type=str,
                        metavar="FUNCTION_NAME", default="",
                        help="name of function in the source code of which to \
                            generate the abstract cfg")
    parser.add_argument("-fp", "--function-params", type=str,
                        metavar="FUNCTION_PARAMS", default="",
                        help="params of function in the source code of \
                            which to generate the abstract cfg")
    # gentrie.
    parser.add_argument("-lp", "--length-path", type=int, default=3,
                        help="set max DFS depth to LP (GraphGrepSX)")

    # logging.
    parser.add_argument("--no-log-file", action="store_true",
                        default=False)

    args = parser.parse_args()
    cpp_flag = args.use_clang_cpp
    var_flag = not args.no_var
    const_flag = not args.no_const
    cut_flag = not args.no_cut
    sty_flag = args.simplified_types
    in_filename = args.file.name
    function_name = args.function_name
    function_params = args.function_params
    path_length = args.length_path
    spec_out = args.output

    logging.getLogger().handlers[0].setLevel(logging.WARNING)

    if args.no_log_file:
        file_handler = logging.getLogger().handlers[1]
        logging.getLogger().removeHandler(file_handler)

    # Get LLVM-IR using Clang/Clang++.
    print("Getting LLVMIR using clang" + ("++" if cpp_flag else "") + "-7...")
    try:
        llvmir = utils.c_to_ll(in_filename, cpp_flag)
    except RuntimeError:
        print("Got an exception executing c_to_ll().")
        raise
    print("Done.")

    # Generate map from csv.
    # TODO: think about better solution.
    predef_map_dict: dict[int, str] = {
        0: "../../../../classes/map-nomap-0.csv",
        1: "../../../../classes/map-ref-1.csv",
        2: "../../../../classes/map-ref-loadstore-2.csv",
        3: "../../../../classes/map-ref-loadstore-phicall-3.csv",
        4: "../../../../classes/map-ref-more-detail-4.csv"
    }

    input_map_path: str = ""
    if args.mapping.isdigit():
        map_id: int = int(args.mapping)
        try:
            input_map: str = predef_map_dict[map_id]
            input_map_path = os.path.join(os.path.dirname(__file__),
                                          input_map)
        except Exception:
            logging.error(f"Invalid mapping ID {map_id}")
            logging.error(f"Valid mapping IDs: {list(predef_map_dict.keys())}")
            raise
    else:
        input_map_path = args.mapping

    logging.info(f"Generating map from csv '{input_map_path}'... ")
    map: list[dict] = gencfg.gen_map_from_csv(input_map_path)
    logging.info(f"Generating map from csv '{input_map_path}'... done.")

    function_name_found = ""

    print("Generating absract CFG... ")
    if function_name:
        # Generate abstract cfg of (eventually) specified function.
        try:
            A, O, function_name_found = gencfg.generate_acfg_one_function(
                llvmir, map, var_flag, const_flag, sty_flag, cut_flag,
                function_name, function_params)
        except BaseException:
            print("Got an exception executing gencfg().")
            raise
        # A: abstract cfg of 'function_name_found'
        # G: original cfg of 'function_name_found'
        print(f"...found function {function_name_found}...")
    else:
        A = gencfg.generate_acfg(llvmir, map, var_flag, const_flag,
                                 sty_flag, cut_flag)

    print("done.")

    # print(nx.nx_pydot.to_pydot(A))
    # print(nx.nx_pydot.to_pydot(O))

    # Generate prefix tree.
    try:
        print("Generating the prefix tree... ", end="")
        # Save .grapes if extra_output_flag.
        # save_path = None
        # if extra_output_flag:
        #     save_path = Path(filename_in).stem + ".grapes"
        T: Trie = Trie(A, path_length, None)
        print("done.")
    except BaseException:
        print("Got an exception executing generate_trie().")
        raise

    # Output.
    if not spec_out:
        spec_out = "trie-acfg-" + pathlib.Path(in_filename).stem + ".dot"
    out_path = pathlib.Path(spec_out)
    nx.nx_pydot.write_dot(T.get_nxtree(), out_path)
    print(f"Prefix tree printed in '{out_path}'.")


if __name__ == "__main__":
    main()
